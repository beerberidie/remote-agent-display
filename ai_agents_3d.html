
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>AI Agents – 3D Neural Graph</title>
<style>
  :root{
    --bg:#0b1020; --fg:#e5e7eb;
    --blue:#60a5fa; --yellow:#f59e0b; --green:#34d399; --pink:#f472b6;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{
    position:fixed;top:0;left:0;right:0;z-index:10;
    display:flex;align-items:center;justify-content:space-between;gap:12px;
    padding:10px 14px;background:rgba(10,13,25,.75);backdrop-filter:blur(8px);border-bottom:1px solid rgba(148,163,184,.2)
  }
  .legend{display:flex;gap:12px;align-items:center;font-size:12px;color:#cbd5e1}
  .chip{display:flex;align-items:center;gap:6px}
  .dot{width:10px;height:10px;border-radius:50%}
  .toolbar{display:flex;gap:8px;align-items:center}
  .btn{background:#2563eb;color:white;border:0;border-radius:8px;padding:8px 12px;cursor:pointer;font-weight:600}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .panel{
    position:fixed;right:12px;top:64px;z-index:9;width:280px;
    background:rgba(17,24,39,.75);backdrop-filter:blur(8px);
    border:1px solid rgba(148,163,184,.2);border-radius:12px;padding:12px;color:#e5e7eb;font-size:13px
  }
  .panel h3{margin:0 0 8px;font-size:14px}
  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  .row>*{flex:1}
  select,input[type=color],input[type=range]{width:100%;background:#0f172a;color:#e5e7eb;border:1px solid #2c3443;border-radius:8px;padding:6px}
  label{color:#cbd5e1;font-size:12px}
  #app{height:100%;}
  .tip{
    position:fixed;pointer-events:none;z-index:20;transform:translate(-50%,-120%);
    background:#0b1220;border:1px solid rgba(148,163,184,.25);border-radius:8px;padding:6px 8px;font-size:12px;color:#e5e7eb;
    box-shadow:0 8px 20px rgba(0,0,0,.35);opacity:0;transition:opacity .08s;
  }
  canvas{display:block}
</style>
</head>
<body>
<header>
  <div class="legend">
    <strong>AI Agents – 3D Neural Graph</strong>
    <span class="chip"><span class="dot" style="background:var(--blue)"></span>Supervisor</span>
    <span class="chip"><span class="dot" style="background:var(--yellow)"></span>Core Dev</span>
    <span class="chip"><span class="dot" style="background:var(--green)"></span>Cross‑Cutting</span>
    <span class="chip"><span class="dot" style="background:var(--pink)"></span>Ops/Support</span>
  </div>
  <div class="toolbar">
    <button class="btn" id="resetCam">Reset Camera</button>
    <button class="btn" id="exportPng">Export PNG</button>
  </div>
</header>

<div class="panel">
  <h3>Highlight connections</h3>
  <div class="row">
    <label for="nodeSel">Node</label>
    <select id="nodeSel"></select>
  </div>
  <div class="row">
    <label for="dirSel">Direction</label>
    <select id="dirSel">
      <option value="out" selected>Outbound</option>
      <option value="in">Inbound</option>
      <option value="both">Both</option>
    </select>
  </div>
  <div class="row">
    <label for="lineColor">Line Color</label>
    <input id="lineColor" type="color" value="#22d3ee"/>
  </div>
  <div class="row">
    <label for="sphere">Layout radius</label>
    <input id="sphere" type="range" min="20" max="65" step="1" value="45"/>
  </div>
  <div class="row">
    <label><input type="checkbox" id="pulse" checked/> Pulse on highlight</label>
  </div>
  <div class="row">
    <button class="btn" id="btnOrc">Orchestrator → all</button>
    <button class="btn" id="btnClear">Clear</button>
  </div>
</div>

<div id="app"></div>
<div class="tip" id="tip"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
import {CSS2DRenderer, CSS2DObject} from 'three/addons/renderers/CSS2DRenderer.js';

// --- Data ---
const nodes = [
  {id:"orchestrator", name:"Chief Orchestrator", role:"Local Supervisor", group:"super"},
  {id:"product",  name:"Product Owner", role:"Local", group:"core"},
  {id:"ux",       name:"UX/UI & Accessibility", role:"Hybrid", group:"core"},
  {id:"api",      name:"API Contract & Gateway", role:"Hybrid → Remote", group:"core"},
  {id:"data",     name:"Data Modeling & Migrations", role:"Hybrid → Remote", group:"core"},
  {id:"frontend", name:"Frontend Delivery", role:"Remote", group:"core"},
  {id:"backend",  name:"Backend Delivery", role:"Remote", group:"core"},
  {id:"async",    name:"Async Jobs & Workflows", role:"Remote", group:"core"},
  {id:"qa",       name:"QA & Test Automation", role:"Remote", group:"cross"},
  {id:"security", name:"Security & Compliance", role:"Remote (guardrailed)", group:"cross"},
  {id:"devops",   name:"DevOps & Platform", role:"Hybrid", group:"cross"},
  {id:"observ",   name:"Observability & Telemetry", role:"Remote", group:"cross"},
  {id:"privacy",  name:"Privacy & DPO", role:"Hybrid", group:"cross"},
  {id:"perf",     name:"Performance & Cost", role:"Remote", group:"cross"},
  {id:"analytics",name:"Product Analytics", role:"Remote", group:"cross"},
  {id:"dataeng",  name:"Data Engineering", role:"Remote", group:"cross"},
  {id:"mlops",    name:"MLOps & Governance", role:"Hybrid → Remote", group:"cross"},
  {id:"supply",   name:"Supply Chain & Deps", role:"Remote", group:"cross"},
  {id:"codeq",    name:"Code Quality & Standards", role:"Remote", group:"cross"},
  {id:"sre",      name:"SRE & Runbooks", role:"Hybrid", group:"ops"},
  {id:"release",  name:"Release & Change Mgmt", role:"Local", group:"ops"},
  {id:"support",  name:"Support/Triage", role:"Hybrid", group:"ops"},
  {id:"incident", name:"Incident Commander", role:"Local", group:"ops"},
  {id:"context",  name:"Context & Knowledge", role:"Hybrid", group:"ops"},
];
const edges = [
  ["orchestrator","product"],["orchestrator","ux"],["orchestrator","api"],["orchestrator","data"],
  ["orchestrator","frontend"],["orchestrator","backend"],["orchestrator","async"],["orchestrator","qa"],
  ["orchestrator","security"],["orchestrator","devops"],["orchestrator","observ"],["orchestrator","sre"],
  ["orchestrator","release"],["orchestrator","privacy"],["orchestrator","perf"],["orchestrator","analytics"],
  ["orchestrator","dataeng"],["orchestrator","mlops"],["orchestrator","supply"],["orchestrator","codeq"],
  ["orchestrator","support"],["orchestrator","incident"],["orchestrator","context"],
  ["product","api"],["api","backend"],["data","backend"],
  ["backend","async"],["frontend","qa"],["backend","qa"],["qa","release"],
  ["security","devops"],["devops","observ"],["observ","sre"],
  ["sre","incident"],["privacy","backend"],["perf","backend"],
  ["analytics","frontend"],["dataeng","analytics"],["mlops","backend"],
  ["supply","devops"],["codeq","frontend"],["codeq","backend"],
  ["support","qa"],["sre","context"],["context","product"],
];

// Colors
const groupColor = g => g==='super' ? getComputedStyle(document.documentElement).getPropertyValue('--blue')
                    : g==='core' ? getComputedStyle(document.documentElement).getPropertyValue('--yellow')
                    : g==='cross'? getComputedStyle(document.documentElement).getPropertyValue('--green')
                    : getComputedStyle(document.documentElement).getPropertyValue('--pink');

// Scene
const container = document.getElementById('app');
const scene = new THREE.Scene();
scene.background = new THREE.Color(getComputedStyle(document.body).backgroundColor);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 0, 150);

const renderer = new THREE.WebGLRenderer({antialias:true,preserveDrawingBuffer:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
container.appendChild(renderer.domElement);

const labelRenderer = new CSS2DRenderer();
labelRenderer.setSize(innerWidth, innerHeight);
labelRenderer.domElement.style.position = 'fixed';
labelRenderer.domElement.style.top = '0px';
labelRenderer.domElement.style.pointerEvents = 'none';
container.appendChild(labelRenderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Lights
const hemi = new THREE.HemisphereLight(0x88aaff, 0x232323, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(50, 80, 120);
scene.add(dir);

// Starfield bg
const stars = new THREE.Points(
  new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(Array.from({length: 3000},()=> (Math.random()-0.5)*1200),3)),
  new THREE.PointsMaterial({color:0x334155,size:0.8,transparent:true,opacity:0.6})
);
scene.add(stars);

// Layout: distribute nodes on a sphere using golden spiral
const radiusControl = document.getElementById('sphere');
let sphereRadius = parseFloat(radiusControl.value);
function positionOnSphere(i, n, r){
  const phi = Math.acos(1 - 2*(i+0.5)/n);
  const theta = Math.PI * (1 + Math.sqrt(5)) * (i+0.5);
  return new THREE.Vector3(
    r*Math.cos(theta)*Math.sin(phi),
    r*Math.sin(theta)*Math.sin(phi),
    r*Math.cos(phi)
  );
}

const nodeMap = new Map();
const edgeMap = [];

const nodeGeom = new THREE.SphereGeometry(2.6, 32, 32);
const haloGeom = new THREE.SphereGeometry(3.2, 32, 32);
nodes.forEach((n, i) => {
  const color = new THREE.Color(groupColor(n.group).trim() || '#888');
  const mat = new THREE.MeshStandardMaterial({color, metalness:0.1, roughness:0.4});
  const mesh = new THREE.Mesh(nodeGeom, mat);
  mesh.position.copy(positionOnSphere(i, nodes.length, sphereRadius));
  mesh.userData = { id:n.id, name:n.name, role:n.role, group:n.group };
  // halo
  const haloMat = new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.08});
  const halo = new THREE.Mesh(haloGeom, haloMat);
  mesh.add(halo);
  scene.add(mesh);

  // label
  const label = document.createElement('div');
  label.style.color = '#e5e7eb';
  label.style.fontSize = '11px';
  label.style.padding = '2px 6px';
  label.style.background = 'rgba(0,0,0,0.4)';
  label.style.border = '1px solid rgba(148,163,184,.25)';
  label.style.borderRadius = '6px';
  label.textContent = n.name;
  const labelObj = new CSS2DObject(label);
  labelObj.position.set(0, 4.5, 0);
  mesh.add(labelObj);

  nodeMap.set(n.id, mesh);
});

// Edges as individual lines (for highlighting)
const lineMat = new THREE.LineBasicMaterial({color:0x94a3b8, transparent:true, opacity:0.6});
edges.forEach(([a,b]) => {
  const ga = nodeMap.get(a).position;
  const gb = nodeMap.get(b).position;
  const geom = new THREE.BufferGeometry().setFromPoints([ga.clone(), gb.clone()]);
  const line = new THREE.Line(geom, lineMat.clone());
  line.userData = { from:a, to:b };
  scene.add(line);
  edgeMap.push(line);
});

// Raycaster for picking
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const tip = document.getElementById('tip');

function onPointerMove(e){
  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(Array.from(nodeMap.values()));
  if (intersects.length){
    const m = intersects[0].object;
    tip.style.opacity = 1;
    tip.style.left = e.clientX + 'px';
    tip.style.top = e.clientY + 'px';
    tip.textContent = `${m.userData.name} · ${m.userData.role}`;
  } else {
    tip.style.opacity = 0;
  }
}
window.addEventListener('pointermove', onPointerMove);

// Highlight logic
const nodeSel = document.getElementById('nodeSel');
nodes.forEach(n => {
  const opt = document.createElement('option'); opt.value = n.id; opt.textContent = n.name;
  nodeSel.appendChild(opt);
});
nodeSel.value = 'orchestrator';

const dirSel = document.getElementById('dirSel');
const lineColor = document.getElementById('lineColor');
const pulse = document.getElementById('pulse');

function clearHighlight(){
  edgeMap.forEach(l => { l.material.color.set(0x94a3b8); l.material.linewidth = 1; l.material.opacity = 0.25; });
  nodeMap.forEach(m => { m.children[0].material.opacity = 0.08; m.scale.set(1,1,1); });
}
function applyHighlight(){
  clearHighlight();
  const id = nodeSel.value;
  const dir = dirSel.value;
  const color = new THREE.Color(lineColor.value);
  const sel = nodeMap.get(id);
  if (!sel) return;
  // emphasize selected node
  sel.scale.set(1.25,1.25,1.25);
  sel.children[0].material.opacity = 0.18;

  edgeMap.forEach(line => {
    const {from,to} = line.userData;
    const match = (dir==='out' && from===id) || (dir==='in' && to===id) || (dir==='both' && (from===id || to===id));
    if (match){
      line.material.color = color;
      line.material.opacity = 0.95;
      if (pulse.checked) line.userData.pulse = (Math.random()*Math.PI);
    } else {
      line.material.opacity = 0.08;
    }
  });
}
document.getElementById('btnOrc').onclick = () => { nodeSel.value='orchestrator'; dirSel.value='out'; lineColor.value='#22d3ee'; applyHighlight(); };
document.getElementById('btnClear').onclick = () => { clearHighlight(); };
nodeSel.onchange = applyHighlight; dirSel.onchange = applyHighlight; lineColor.oninput = applyHighlight;

// Camera controls
document.getElementById('resetCam').onclick = ()=>{
  camera.position.set(0,0,150);
  controls.target.set(0,0,0);
  controls.update();
};

// Layout radius control
radiusControl.addEventListener('input', (e)=>{
  sphereRadius = parseFloat(e.target.value);
  nodes.forEach((n,i)=>{
    const pos = positionOnSphere(i, nodes.length, sphereRadius);
    nodeMap.get(n.id).position.copy(pos);
  });
  // update edge geometry
  edgeMap.forEach((line, idx)=>{
    const [a,b] = edges[idx];
    const ga = nodeMap.get(a).position;
    const gb = nodeMap.get(b).position;
    line.geometry.setFromPoints([ga.clone(), gb.clone()]);
    line.geometry.attributes.position.needsUpdate = true;
  });
});

// Export PNG
document.getElementById('exportPng').onclick = ()=>{
  const link = document.createElement('a');
  link.download = 'ai_agents_3d.png';
  link.href = renderer.domElement.toDataURL('image/png');
  link.click();
};

// Animate
function animate(t){
  requestAnimationFrame(animate);
  controls.update();
  // Pulsing edges
  edgeMap.forEach(line=>{
    if (line.userData.pulse !== undefined){
      const a = (Math.sin(t*0.004 + line.userData.pulse)*0.5+0.5);
      line.material.opacity = 0.6 + a*0.35;
    }
  });
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}
animate(0);

// Initial highlight
applyHighlight();
</script>

</body>
</html>
